Continious integration / Continious delivery - это про получение предсказуемых, воспроизводимых, регулярных результатов

#1

CI - добавлять разработку в ветку как можно чаще, мелкими порциями (атомарные коммиты) при этом
автоматизированно контролируя их качество (Прочитать про экстремальное программирование)
Суть - понять что система находится в потенциально сломанном состоянии как можно раньше (система запускает автототесты, линтеры)
    Позволяет понять что основная ветка находится в работоспособном состоянии

CD - когда продукт попадает на сервер. Эффективность определяется временем между тем как обновление попало на основную ветку,
    и тем, когда продукт увидел конечный пользователь. Этот подход позволяет итерироваться быстее. Чем меньше итерация, тем меньше нужно резолвить конфликтов.

Incremental rollout - когда большая компания (напр Facebook) тестирует фичи на клиентах путем выкативания и тестирования
    с увеличением количества пользователей -  0.1% - 1% - 10% - 100% Если успешная фича то количество пользователей увеличивают


#2 

Существует хранилище и координатор а так же конфигурационный файл. Суть - происходит событие в хранилище (github, gitlab), и у нас 
есть инструкции, которые описывают действия. Например -запустить линтер или тестирование. Бывает интегрированные решения и сторонние (jenkins). .gitlab-ci.yaml .githubworkflow - файлы конфигурации. 

Файл конфигурации делится на более маленькие с зависимостями - jobs

Runner - выполняет рабочие задачи, может выполнять несколько. Периодически опрашивает координатора для получения работ. Когда он ее получил и выполнил, отправляет результат - успешно или нет. 
Job - может сгенерировать набор файлов - артефакты. В них можно обращаться по API для выполнения доп функционала.
Yaml - язык конфигурации для выполнения программ - описывает что делать и планирует jobs

Процесс: Происходит событие, вручную запускаем, по расписанию в хранилище -> координатор создает jobs с переменными окружения и передает Runner -> Он выполняет инструкции -> вынимает репозиторий и работает с ним -> передает результат обратно координатору 

!!!!!! Важное - когда pipline запускается конфигурации не меняются для соблюдения идемпотентности. Если были произведены изменения, то нужно перезапустить pipline

#3

Определения названий.

Pipline - все с чем мы работаем в CI. Так как все протекает с одной точки в другую. Он состоит из jobs

Job - одна задача которая решает атомарную смысловую еденицу. Например запустить - eslint, prettier, webpack сборку, запустить tests или отобразить диаграмму результатами. Важно разбивать на смысловые еденицы. (Набор программ похож на открытую консоль, в которой просто вводятся программы и выполняются).

Зависимости между jos - указыают, что одна не должна выполняться, пока не выполнится другая и тд. Могут быть двух типов:
- Зависимости реальной необходимости

Артефакты - результаты работы jobs. Например статистика, которую можно использовать для визуализации прохождения тестов

Runner - "железка" которая выполняет jobs. Например gitlab runner на удаленном сервере

Stage - gitlab определение. Способ группировки jobs, в каком порядке их выполнять. Линейная структура пошагового выполнения задач lint -> build -> test -> deploy

Scripts - сценарий того как будет выполняться job

Steps - шаги внутри job, которые нужно выполнять

#4

Не стесняться разбивать Pipline на достаточно мелкие jobs. Это поможет в случае если упадет проверка быстро найти проблему.
package-lock.json - предназначен для воспроизводимости установки. Сохраняет необходимые версии.
При создании job учитывать версию Node чтобы получать предсказуемость работы
Для установки пакетов использовать npm ci или yarn --frozen-lockfile
yarn --frozen-lockfile позволяет в случае несоответствия версий укажет ошибку
yarn.lock есть функционал который позволяет автоматически резолвить конфликты которые могут возникать
Для отслеживания результата есть код возврата. 0 - говорит о том что все произошло успешно, любой другой код говорит о проблеме. Коды могут быть как положительными так и отрицательными, особой стандартизации кодов которые возвращаются нет. Единственное соглашение - 0 значит что все хорошо